{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\n\n/*\ngetOriginalCounterPart gets the index of the original children.\nFor example, we have an array [clones, originalChildren, clones];\nBefore making the clones, an item's index is 0, but after the clone,\nthe index is different it could be 4, because we added clones to the array after \"componentDidMount\".\nAnd this function gets the \"index\" of the item after the clones.\n*/\nfunction getOriginalCounterPart(index, _ref, childrenArr) {\n  var slidesToShow = _ref.slidesToShow,\n      currentSlide = _ref.currentSlide;\n\n  // this function is only used for \"infinite and showDots are true\";\n  if (childrenArr.length > slidesToShow * 2) {\n    var originalCouterPart = index + slidesToShow * 2;\n    return originalCouterPart;\n  } else {\n    if (currentSlide >= childrenArr.length) {\n      return childrenArr.length + index;\n    } else {\n      return index;\n    }\n  }\n}\n/*\nA slide can have many clones, this produces a hash table structure for us to know \nWhat is the clone of a particular slide and where it is. Note: a slide can have multiple clones.\nThis is based on the getclones method below.\n*/\n\n\nfunction getOriginalIndexLookupTableByClones(slidesToShow, childrenArr) {\n  if (childrenArr.length > slidesToShow * 2) {\n    var table = {};\n    var firstBeginningOfClones = childrenArr.length - slidesToShow * 2;\n    var firstEndOfClones = childrenArr.length - firstBeginningOfClones;\n    var firstCount = firstBeginningOfClones;\n\n    for (var i = 0; i < firstEndOfClones; i++) {\n      table[i] = firstCount;\n      firstCount++;\n    }\n\n    var secondBeginningOfClones = childrenArr.length + firstEndOfClones;\n    var secondEndOfClones = secondBeginningOfClones + childrenArr.slice(0, slidesToShow * 2).length;\n    var secondCount = 0;\n\n    for (var _i = secondBeginningOfClones; _i <= secondEndOfClones; _i++) {\n      table[_i] = secondCount;\n      secondCount++;\n    }\n\n    var originalStart = firstEndOfClones;\n    var originalEnd = secondBeginningOfClones;\n    var originalCounter = 0;\n\n    for (var _i2 = originalStart; _i2 < originalEnd; _i2++) {\n      table[_i2] = originalCounter;\n      originalCounter++;\n    }\n\n    return table;\n  } else {\n    var _table = {};\n    var totalSlides = childrenArr.length * 3; // the origianl children array gets clone 3 times.\n\n    var count = 0;\n\n    for (var _i3 = 0; _i3 < totalSlides; _i3++) {\n      _table[_i3] = count;\n      count++;\n\n      if (count === childrenArr.length) {\n        count = 0;\n      }\n    }\n\n    return _table;\n  }\n}\n/*\nThe current setting is if the length of the carousel item is larger than \"slidesToShow * 2\",\nthen we clone \"slidesToShow * 2\" amount of beginning and end items.\n\nOtherwise, it means we only have a few items. Then we clone it 3 times.\n*/\n\n\nfunction getClones(slidesToShow, childrenArr) {\n  var clones;\n\n  if (childrenArr.length > slidesToShow * 2) {\n    clones = [].concat(_toConsumableArray(childrenArr.slice(childrenArr.length - slidesToShow * 2, childrenArr.length)), _toConsumableArray(childrenArr), _toConsumableArray(childrenArr.slice(0, slidesToShow * 2)));\n  } else {\n    clones = [].concat(_toConsumableArray(childrenArr), _toConsumableArray(childrenArr), _toConsumableArray(childrenArr));\n  }\n\n  return clones;\n}\n\nfunction getInitialSlideInInifteMode(slidesToShow, childrenArr) {\n  if (childrenArr.length > slidesToShow * 2) {\n    return slidesToShow * 2;\n  } else {\n    return childrenArr.length;\n  }\n}\n/*\nWhen the user sees the clones, we need to reset the position, and cancel the animation so that it\ncreates the infinite effects.\n\nThe if else statement here is based on the getClones method. Because it decides how many items we are cloning.\n*/\n\n\nfunction checkClonesPosition(_ref2, childrenArr, props) {\n  var currentSlide = _ref2.currentSlide,\n      slidesToShow = _ref2.slidesToShow,\n      itemWidth = _ref2.itemWidth,\n      totalItems = _ref2.totalItems;\n  // the one is here for pre-swtiching the position just right before we are one more slide away from the end.\n  // this gives us enough time to pre-clone the carousel items.\n  var nextSlide = 0;\n  var nextPosition = 0;\n  var isReachingTheEnd;\n  var isReachingTheStart = currentSlide === 0;\n  var originalFirstSlide = childrenArr.length - (childrenArr.length - slidesToShow * 2);\n\n  if (childrenArr.length > slidesToShow * 2) {\n    isReachingTheEnd = currentSlide >= originalFirstSlide + childrenArr.length;\n\n    if (isReachingTheEnd) {\n      nextSlide = currentSlide - childrenArr.length;\n      nextPosition = -(itemWidth * nextSlide);\n    }\n\n    if (isReachingTheStart) {\n      nextSlide = originalFirstSlide + (childrenArr.length - slidesToShow * 2);\n      nextPosition = -(itemWidth * nextSlide);\n    }\n  } else {\n    isReachingTheEnd = currentSlide >= childrenArr.length * 2;\n\n    if (isReachingTheEnd) {\n      nextSlide = currentSlide - childrenArr.length;\n      nextPosition = -(itemWidth * nextSlide);\n    }\n\n    if (isReachingTheStart) {\n      if (props.showDots) {\n        nextSlide = childrenArr.length;\n        nextPosition = -(itemWidth * nextSlide);\n      } else {\n        nextSlide = totalItems - slidesToShow * 2;\n        nextPosition = -(itemWidth * nextSlide);\n      }\n    }\n  }\n\n  return {\n    isReachingTheEnd: isReachingTheEnd,\n    isReachingTheStart: isReachingTheStart,\n    nextSlide: nextSlide,\n    nextPosition: nextPosition\n  };\n}\n\nexport { getOriginalCounterPart, getOriginalIndexLookupTableByClones, getClones, checkClonesPosition, getInitialSlideInInifteMode };","map":{"version":3,"sources":["/Users/admin/Desktop/REACT/with-apollo-app/components/utils/clones.js"],"names":["getOriginalCounterPart","index","childrenArr","slidesToShow","currentSlide","length","originalCouterPart","getOriginalIndexLookupTableByClones","table","firstBeginningOfClones","firstEndOfClones","firstCount","i","secondBeginningOfClones","secondEndOfClones","slice","secondCount","originalStart","originalEnd","originalCounter","totalSlides","count","getClones","clones","getInitialSlideInInifteMode","checkClonesPosition","props","itemWidth","totalItems","nextSlide","nextPosition","isReachingTheEnd","isReachingTheStart","originalFirstSlide","showDots"],"mappings":"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","sourcesContent":["/*\ngetOriginalCounterPart gets the index of the original children.\nFor example, we have an array [clones, originalChildren, clones];\nBefore making the clones, an item's index is 0, but after the clone,\nthe index is different it could be 4, because we added clones to the array after \"componentDidMount\".\nAnd this function gets the \"index\" of the item after the clones.\n*/\nfunction getOriginalCounterPart(\n  index,\n  { slidesToShow, currentSlide },\n  childrenArr\n) {\n  // this function is only used for \"infinite and showDots are true\";\n  if (childrenArr.length > slidesToShow * 2) {\n    const originalCouterPart = index + slidesToShow * 2;\n    return originalCouterPart;\n  } else {\n    if (currentSlide >= childrenArr.length) {\n      return childrenArr.length + index;\n    } else {\n      return index;\n    }\n  }\n}\n/*\nA slide can have many clones, this produces a hash table structure for us to know \nWhat is the clone of a particular slide and where it is. Note: a slide can have multiple clones.\nThis is based on the getclones method below.\n*/\n\nfunction getOriginalIndexLookupTableByClones(slidesToShow, childrenArr) {\n  if (childrenArr.length > slidesToShow * 2) {\n    const table = {};\n    const firstBeginningOfClones = childrenArr.length - slidesToShow * 2;\n    const firstEndOfClones = childrenArr.length - firstBeginningOfClones;\n    let firstCount = firstBeginningOfClones;\n    for (let i = 0; i < firstEndOfClones; i++) {\n      table[i] = firstCount;\n      firstCount++;\n    }\n    const secondBeginningOfClones = childrenArr.length + firstEndOfClones;\n    const secondEndOfClones =\n      secondBeginningOfClones + childrenArr.slice(0, slidesToShow * 2).length;\n    let secondCount = 0;\n    for (let i = secondBeginningOfClones; i <= secondEndOfClones; i++) {\n      table[i] = secondCount;\n      secondCount++;\n    }\n    const originalStart = firstEndOfClones;\n    const originalEnd = secondBeginningOfClones;\n    let originalCounter = 0;\n    for (let i = originalStart; i < originalEnd; i++) {\n      table[i] = originalCounter;\n      originalCounter++;\n    }\n    return table;\n  } else {\n    const table = {};\n    const totalSlides = childrenArr.length * 3; // the origianl children array gets clone 3 times.\n    let count = 0;\n    for (let i = 0; i < totalSlides; i++) {\n      table[i] = count;\n      count++;\n      if (count === childrenArr.length) {\n        count = 0;\n      }\n    }\n    return table;\n  }\n}\n\n/*\nThe current setting is if the length of the carousel item is larger than \"slidesToShow * 2\",\nthen we clone \"slidesToShow * 2\" amount of beginning and end items.\n\nOtherwise, it means we only have a few items. Then we clone it 3 times.\n*/\nfunction getClones(slidesToShow, childrenArr) {\n  let clones;\n  if (childrenArr.length > slidesToShow * 2) {\n    clones = [\n      ...childrenArr.slice(\n        childrenArr.length - slidesToShow * 2,\n        childrenArr.length\n      ),\n      ...childrenArr,\n      ...childrenArr.slice(0, slidesToShow * 2)\n    ];\n  } else {\n    clones = [...childrenArr, ...childrenArr, ...childrenArr];\n  }\n  return clones;\n}\n\nfunction getInitialSlideInInifteMode(slidesToShow, childrenArr) {\n  if (childrenArr.length > slidesToShow * 2) {\n    return slidesToShow * 2;\n  } else {\n    return childrenArr.length;\n  }\n}\n\n/*\nWhen the user sees the clones, we need to reset the position, and cancel the animation so that it\ncreates the infinite effects.\n\nThe if else statement here is based on the getClones method. Because it decides how many items we are cloning.\n*/\nfunction checkClonesPosition(\n  { currentSlide, slidesToShow, itemWidth, totalItems },\n  childrenArr,\n  props\n) {\n  // the one is here for pre-swtiching the position just right before we are one more slide away from the end.\n  // this gives us enough time to pre-clone the carousel items.\n  let nextSlide = 0;\n  let nextPosition = 0;\n  let isReachingTheEnd;\n  const isReachingTheStart = currentSlide === 0;\n  const originalFirstSlide =\n    childrenArr.length - (childrenArr.length - slidesToShow * 2);\n  if (childrenArr.length > slidesToShow * 2) {\n    isReachingTheEnd = currentSlide >= originalFirstSlide + childrenArr.length;\n    if (isReachingTheEnd) {\n      nextSlide = currentSlide - childrenArr.length;\n      nextPosition = -(itemWidth * nextSlide);\n    }\n    if (isReachingTheStart) {\n      nextSlide = originalFirstSlide + (childrenArr.length - slidesToShow * 2);\n      nextPosition = -(itemWidth * nextSlide);\n    }\n  } else {\n    isReachingTheEnd = currentSlide >= childrenArr.length * 2;\n    if (isReachingTheEnd) {\n      nextSlide = currentSlide - childrenArr.length;\n      nextPosition = -(itemWidth * nextSlide);\n    }\n    if (isReachingTheStart) {\n      if (props.showDots) {\n        nextSlide = childrenArr.length;\n        nextPosition = -(itemWidth * nextSlide);\n      } else {\n        nextSlide = totalItems - slidesToShow * 2;\n        nextPosition = -(itemWidth * nextSlide);\n      }\n    }\n  }\n  return {\n    isReachingTheEnd,\n    isReachingTheStart,\n    nextSlide,\n    nextPosition\n  };\n}\n\nexport {\n  getOriginalCounterPart,\n  getOriginalIndexLookupTableByClones,\n  getClones,\n  checkClonesPosition,\n  getInitialSlideInInifteMode\n};\n"]},"metadata":{},"sourceType":"module"}