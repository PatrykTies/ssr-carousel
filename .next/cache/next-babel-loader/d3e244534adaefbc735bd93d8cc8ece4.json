{"ast":null,"code":"import { getSlidesToSlide } from \"./common\";\n/*\ntwo cases:\n1. We are not over-sliding.\n2. We are sliding over to what we have, that means nextslides > this.props.children.length. (does not apply to the inifnite mode)\n*/\n\nfunction populateNextSlides(state, props) {\n  var slidesHavePassed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var slidesToShow = state.slidesToShow,\n      currentSlide = state.currentSlide,\n      itemWidth = state.itemWidth,\n      totalItems = state.totalItems;\n  var slidesToSlide = getSlidesToSlide(state, props);\n  var nextSlides;\n  var nextPosition; // possibile next number of slides that don't go over what we have, this doesn't apply to the infinite mode.\n  // because for inifnite mode this will never happen.\n\n  var nextMaximumSlides = currentSlide + 1 + slidesHavePassed + slidesToShow + (slidesHavePassed > 0 ? 0 : slidesToSlide);\n\n  if (nextMaximumSlides <= totalItems) {\n    // It means if we have next slides go back to on the right-hand side.\n    nextSlides = currentSlide + slidesHavePassed + (slidesHavePassed > 0 ? 0 : slidesToSlide);\n    nextPosition = -(itemWidth * nextSlides);\n  } else if (nextMaximumSlides > totalItems && currentSlide !== totalItems - slidesToShow) {\n    // This is to prevent oversliding\n    // This is not for inifinite mode as for inifinite mode is never over-sliding.\n    nextSlides = totalItems - slidesToShow;\n    nextPosition = -(itemWidth * nextSlides);\n  } else {\n    nextSlides = undefined;\n    nextPosition = undefined;\n  }\n\n  return {\n    nextSlides: nextSlides,\n    nextPosition: nextPosition\n  };\n}\n\nexport { populateNextSlides };","map":{"version":3,"sources":["/Users/admin/Desktop/REACT/with-apollo-app/components/utils/next.js"],"names":["getSlidesToSlide","populateNextSlides","state","props","slidesHavePassed","slidesToShow","currentSlide","itemWidth","totalItems","slidesToSlide","nextSlides","nextPosition","nextMaximumSlides","undefined"],"mappings":"AAAA,SAASA,gBAAT,QAAiC,UAAjC;AAEA;;;;;;AAKA,SAASC,kBAAT,CAA4BC,KAA5B,EAAmCC,KAAnC,EAAgE;AAAA,MAAtBC,gBAAsB,uEAAH,CAAG;AAAA,MACtDC,YADsD,GACAH,KADA,CACtDG,YADsD;AAAA,MACxCC,YADwC,GACAJ,KADA,CACxCI,YADwC;AAAA,MAC1BC,SAD0B,GACAL,KADA,CAC1BK,SAD0B;AAAA,MACfC,UADe,GACAN,KADA,CACfM,UADe;AAE9D,MAAMC,aAAa,GAAGT,gBAAgB,CAACE,KAAD,EAAQC,KAAR,CAAtC;AACA,MAAIO,UAAJ;AACA,MAAIC,YAAJ,CAJ8D,CAK9D;AACA;;AACA,MAAMC,iBAAiB,GACrBN,YAAY,GACZ,CADA,GAEAF,gBAFA,GAGAC,YAHA,IAICD,gBAAgB,GAAG,CAAnB,GAAuB,CAAvB,GAA2BK,aAJ5B,CADF;;AAMA,MAAIG,iBAAiB,IAAIJ,UAAzB,EAAqC;AACnC;AACAE,IAAAA,UAAU,GACRJ,YAAY,GACZF,gBADA,IAECA,gBAAgB,GAAG,CAAnB,GAAuB,CAAvB,GAA2BK,aAF5B,CADF;AAIAE,IAAAA,YAAY,GAAG,EAAEJ,SAAS,GAAGG,UAAd,CAAf;AACD,GAPD,MAOO,IACLE,iBAAiB,GAAGJ,UAApB,IACAF,YAAY,KAAKE,UAAU,GAAGH,YAFzB,EAGL;AACA;AACA;AACAK,IAAAA,UAAU,GAAGF,UAAU,GAAGH,YAA1B;AACAM,IAAAA,YAAY,GAAG,EAAEJ,SAAS,GAAGG,UAAd,CAAf;AACD,GARM,MAQA;AACLA,IAAAA,UAAU,GAAGG,SAAb;AACAF,IAAAA,YAAY,GAAGE,SAAf;AACD;;AACD,SAAO;AACLH,IAAAA,UAAU,EAAVA,UADK;AAELC,IAAAA,YAAY,EAAZA;AAFK,GAAP;AAID;;AAED,SAASV,kBAAT","sourcesContent":["import { getSlidesToSlide } from \"./common\";\n\n/*\ntwo cases:\n1. We are not over-sliding.\n2. We are sliding over to what we have, that means nextslides > this.props.children.length. (does not apply to the inifnite mode)\n*/\nfunction populateNextSlides(state, props, slidesHavePassed = 0) {\n  const { slidesToShow, currentSlide, itemWidth, totalItems } = state;\n  const slidesToSlide = getSlidesToSlide(state, props);\n  let nextSlides;\n  let nextPosition;\n  // possibile next number of slides that don't go over what we have, this doesn't apply to the infinite mode.\n  // because for inifnite mode this will never happen.\n  const nextMaximumSlides =\n    currentSlide +\n    1 +\n    slidesHavePassed +\n    slidesToShow +\n    (slidesHavePassed > 0 ? 0 : slidesToSlide);\n  if (nextMaximumSlides <= totalItems) {\n    // It means if we have next slides go back to on the right-hand side.\n    nextSlides =\n      currentSlide +\n      slidesHavePassed +\n      (slidesHavePassed > 0 ? 0 : slidesToSlide);\n    nextPosition = -(itemWidth * nextSlides);\n  } else if (\n    nextMaximumSlides > totalItems &&\n    currentSlide !== totalItems - slidesToShow\n  ) {\n    // This is to prevent oversliding\n    // This is not for inifinite mode as for inifinite mode is never over-sliding.\n    nextSlides = totalItems - slidesToShow;\n    nextPosition = -(itemWidth * nextSlides);\n  } else {\n    nextSlides = undefined;\n    nextPosition = undefined;\n  }\n  return {\n    nextSlides,\n    nextPosition\n  };\n}\n\nexport { populateNextSlides };\n"]},"metadata":{},"sourceType":"module"}