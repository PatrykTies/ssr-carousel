{"ast":null,"code":"import * as React from \"react\";\nimport { getSlidesToSlide } from './common';\nimport { isInRightEnd } from \"./common\";\n/*\ntwo cases:\n1. We are not over-sliding.\n2. We are sliding over to what we have, that means nextslides < this.props.children.length. (does not apply to the inifnite mode)\n*/\n\nfunction populatePreviousSlides(state, props) {\n  var slidesHavePassed = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var currentSlide = state.currentSlide,\n      itemWidth = state.itemWidth,\n      slidesToShow = state.slidesToShow;\n  var children = props.children,\n      showDots = props.showDots,\n      infinite = props.infinite;\n  var slidesToSlide = getSlidesToSlide(state, props);\n  var nextSlides;\n  var nextPosition;\n  var nextMaximumSlides = currentSlide - slidesHavePassed - (slidesHavePassed > 0 ? 0 : slidesToSlide);\n  var childrenArr = React.Children.toArray(children);\n  var additionalSlides = (childrenArr.length - slidesToShow) % slidesToSlide;\n\n  if (nextMaximumSlides >= 0) {\n    // It means if we have next slides go back to on the left-hand side.\n    nextSlides = nextMaximumSlides;\n\n    if (showDots && !infinite && additionalSlides > 0 && isInRightEnd(state)) {\n      nextSlides = currentSlide - additionalSlides;\n    }\n\n    nextPosition = -(itemWidth * nextSlides);\n  } else if (nextMaximumSlides < 0 && currentSlide !== 0) {\n    // prevent oversliding.\n    // it means the user has almost scrolling over to what we have.\n    // if true, then we go back to the first slide.\n    // this is not for infinite mode as infinite mode always has items to go back to.\n    nextSlides = 0;\n    nextPosition = 0;\n  } else {\n    nextSlides = undefined;\n    nextPosition = undefined;\n  }\n\n  return {\n    nextSlides: nextSlides,\n    nextPosition: nextPosition\n  };\n}\n\nexport { populatePreviousSlides };","map":{"version":3,"sources":["/Users/admin/Desktop/REACT/with-apollo-app/components/utils/previous.js"],"names":["React","getSlidesToSlide","isInRightEnd","populatePreviousSlides","state","props","slidesHavePassed","currentSlide","itemWidth","slidesToShow","children","showDots","infinite","slidesToSlide","nextSlides","nextPosition","nextMaximumSlides","childrenArr","Children","toArray","additionalSlides","length","undefined"],"mappings":"AAAA,OAAO,KAAKA,KAAZ,MAAuB,OAAvB;AACA,SAASC,gBAAT,QAAiC,UAAjC;AACA,SAASC,YAAT,QAA6B,UAA7B;AACA;;;;;;AAKA,SAASC,sBAAT,CACEC,KADF,EAEEC,KAFF,EAIC;AAAA,MADCC,gBACD,uEADoB,CACpB;AAAA,MACSC,YADT,GACmDH,KADnD,CACSG,YADT;AAAA,MACuBC,SADvB,GACmDJ,KADnD,CACuBI,SADvB;AAAA,MACkCC,YADlC,GACmDL,KADnD,CACkCK,YADlC;AAAA,MAESC,QAFT,GAE0CL,KAF1C,CAESK,QAFT;AAAA,MAEmBC,QAFnB,GAE0CN,KAF1C,CAEmBM,QAFnB;AAAA,MAE6BC,QAF7B,GAE0CP,KAF1C,CAE6BO,QAF7B;AAGC,MAAMC,aAAa,GAAGZ,gBAAgB,CAACG,KAAD,EAAOC,KAAP,CAAtC;AACA,MAAIS,UAAJ;AACA,MAAIC,YAAJ;AACA,MAAMC,iBAAiB,GACrBT,YAAY,GACZD,gBADA,IAECA,gBAAgB,GAAG,CAAnB,GAAuB,CAAvB,GAA2BO,aAF5B,CADF;AAIA,MAAMI,WAAW,GAAGjB,KAAK,CAACkB,QAAN,CAAeC,OAAf,CAAuBT,QAAvB,CAApB;AACA,MAAMU,gBAAgB,GAAG,CAACH,WAAW,CAACI,MAAZ,GAAqBZ,YAAtB,IAAsCI,aAA/D;;AACA,MAAIG,iBAAiB,IAAI,CAAzB,EAA4B;AAC1B;AACAF,IAAAA,UAAU,GAAGE,iBAAb;;AACA,QAAIL,QAAQ,IAAI,CAACC,QAAb,IAAyBQ,gBAAgB,GAAG,CAA5C,IAAiDlB,YAAY,CAACE,KAAD,CAAjE,EAA0E;AACxEU,MAAAA,UAAU,GAAGP,YAAY,GAAGa,gBAA5B;AACD;;AACDL,IAAAA,YAAY,GAAG,EAAEP,SAAS,GAAGM,UAAd,CAAf;AACD,GAPD,MAOO,IAAIE,iBAAiB,GAAG,CAApB,IAAyBT,YAAY,KAAK,CAA9C,EAAiD;AACtD;AACA;AACA;AACA;AACAO,IAAAA,UAAU,GAAG,CAAb;AACAC,IAAAA,YAAY,GAAG,CAAf;AACD,GAPM,MAOA;AACLD,IAAAA,UAAU,GAAGQ,SAAb;AACAP,IAAAA,YAAY,GAAGO,SAAf;AACD;;AACD,SAAO;AACLR,IAAAA,UAAU,EAAVA,UADK;AAELC,IAAAA,YAAY,EAAZA;AAFK,GAAP;AAID;;AAED,SAASZ,sBAAT","sourcesContent":["import * as React from \"react\";\nimport { getSlidesToSlide } from './common';\nimport { isInRightEnd } from \"./common\";\n/*\ntwo cases:\n1. We are not over-sliding.\n2. We are sliding over to what we have, that means nextslides < this.props.children.length. (does not apply to the inifnite mode)\n*/\nfunction populatePreviousSlides(\n  state,\n  props,\n  slidesHavePassed = 0\n){\n  const { currentSlide, itemWidth, slidesToShow } = state;\n  const { children, showDots, infinite } = props;\n  const slidesToSlide = getSlidesToSlide(state,props);\n  let nextSlides;\n  let nextPosition;\n  const nextMaximumSlides =\n    currentSlide -\n    slidesHavePassed -\n    (slidesHavePassed > 0 ? 0 : slidesToSlide);\n  const childrenArr = React.Children.toArray(children);\n  const additionalSlides = (childrenArr.length - slidesToShow) % slidesToSlide;\n  if (nextMaximumSlides >= 0) {\n    // It means if we have next slides go back to on the left-hand side.\n    nextSlides = nextMaximumSlides;\n    if (showDots && !infinite && additionalSlides > 0 && isInRightEnd(state)) {\n      nextSlides = currentSlide - additionalSlides;\n    }\n    nextPosition = -(itemWidth * nextSlides);\n  } else if (nextMaximumSlides < 0 && currentSlide !== 0) {\n    // prevent oversliding.\n    // it means the user has almost scrolling over to what we have.\n    // if true, then we go back to the first slide.\n    // this is not for infinite mode as infinite mode always has items to go back to.\n    nextSlides = 0;\n    nextPosition = 0;\n  } else {\n    nextSlides = undefined;\n    nextPosition = undefined;\n  }\n  return {\n    nextSlides,\n    nextPosition,\n  };\n}\n\nexport { populatePreviousSlides };\n"]},"metadata":{},"sourceType":"module"}