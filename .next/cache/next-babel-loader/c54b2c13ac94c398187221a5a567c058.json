{"ast":null,"code":"// this is to get the values for handling onTouchMove / onMouseMove;\nfunction populateSlidesOnMouseTouchMove(state, props, initialX, lastX, clientX) {\n  var itemWidth = state.itemWidth,\n      slidesToShow = state.slidesToShow,\n      totalItems = state.totalItems,\n      transform = state.transform,\n      currentSlide = state.currentSlide;\n  var infinite = props.infinite;\n  var canContinue = false; // it will be true if we have slides to slide to.\n\n  var direction; // either 'left' or 'right'\n\n  var nextPosition; // making sure we have items to slide back to, prevent oversliding.\n\n  var slidesHavePassedRight = Math.round((initialX - lastX) / itemWidth);\n  var slidesHavePassedLeft = Math.round((lastX - initialX) / itemWidth);\n  var isMovingRight = initialX > clientX;\n  var isMovingLeft = clientX > initialX;\n\n  if (isMovingRight) {\n    var isAboutToOverSlide = !(slidesHavePassedRight <= slidesToShow);\n\n    if (!isAboutToOverSlide) {\n      direction = \"right\";\n      var translateXLimit = Math.abs(-(itemWidth * (totalItems - slidesToShow)));\n      var nextTranslate = transform - (lastX - clientX);\n      var isLastSlide = currentSlide === totalItems - slidesToShow;\n\n      if (Math.abs(nextTranslate) <= translateXLimit || isLastSlide && infinite) {\n        nextPosition = nextTranslate;\n        canContinue = true;\n      }\n    }\n  }\n\n  if (isMovingLeft) {\n    var _isAboutToOverSlide = !(slidesHavePassedLeft <= slidesToShow);\n\n    if (!_isAboutToOverSlide) {\n      direction = \"left\";\n\n      var _nextTranslate = transform + (clientX - lastX);\n\n      var isFirstSlide = currentSlide === 0;\n\n      if (_nextTranslate <= 0 || isFirstSlide && infinite) {\n        canContinue = true;\n        nextPosition = _nextTranslate;\n      }\n    }\n  }\n\n  return {\n    direction: direction,\n    nextPosition: nextPosition,\n    canContinue: canContinue\n  };\n}\n\nexport { populateSlidesOnMouseTouchMove };","map":{"version":3,"sources":["/Users/admin/Desktop/REACT/with-apollo-app/components/utils/mouseOrTouchMove.js"],"names":["populateSlidesOnMouseTouchMove","state","props","initialX","lastX","clientX","itemWidth","slidesToShow","totalItems","transform","currentSlide","infinite","canContinue","direction","nextPosition","slidesHavePassedRight","Math","round","slidesHavePassedLeft","isMovingRight","isMovingLeft","isAboutToOverSlide","translateXLimit","abs","nextTranslate","isLastSlide","isFirstSlide"],"mappings":"AAAA;AACA,SAASA,8BAAT,CACEC,KADF,EAEEC,KAFF,EAGEC,QAHF,EAIEC,KAJF,EAKEC,OALF,EAME;AAAA,MAEEC,SAFF,GAOIL,KAPJ,CAEEK,SAFF;AAAA,MAGEC,YAHF,GAOIN,KAPJ,CAGEM,YAHF;AAAA,MAIEC,UAJF,GAOIP,KAPJ,CAIEO,UAJF;AAAA,MAKEC,SALF,GAOIR,KAPJ,CAKEQ,SALF;AAAA,MAMEC,YANF,GAOIT,KAPJ,CAMES,YANF;AAAA,MAQQC,QARR,GAQqBT,KARrB,CAQQS,QARR;AASA,MAAIC,WAAW,GAAG,KAAlB,CATA,CASyB;;AACzB,MAAIC,SAAJ,CAVA,CAUe;;AACf,MAAIC,YAAJ,CAXA,CAYA;;AACA,MAAMC,qBAAqB,GAAGC,IAAI,CAACC,KAAL,CAAW,CAACd,QAAQ,GAAGC,KAAZ,IAAqBE,SAAhC,CAA9B;AACA,MAAMY,oBAAoB,GAAGF,IAAI,CAACC,KAAL,CAAW,CAACb,KAAK,GAAGD,QAAT,IAAqBG,SAAhC,CAA7B;AACA,MAAMa,aAAa,GAAGhB,QAAQ,GAAGE,OAAjC;AACA,MAAMe,YAAY,GAAGf,OAAO,GAAGF,QAA/B;;AACA,MAAIgB,aAAJ,EAAmB;AACjB,QAAME,kBAAkB,GAAG,EAAEN,qBAAqB,IAAIR,YAA3B,CAA3B;;AACA,QAAI,CAACc,kBAAL,EAAyB;AACvBR,MAAAA,SAAS,GAAG,OAAZ;AACA,UAAMS,eAAe,GAAGN,IAAI,CAACO,GAAL,CACtB,EAAEjB,SAAS,IAAIE,UAAU,GAAGD,YAAjB,CAAX,CADsB,CAAxB;AAGA,UAAMiB,aAAa,GAAGf,SAAS,IAAIL,KAAK,GAAGC,OAAZ,CAA/B;AACA,UAAMoB,WAAW,GAAGf,YAAY,KAAKF,UAAU,GAAGD,YAAlD;;AACA,UACES,IAAI,CAACO,GAAL,CAASC,aAAT,KAA2BF,eAA3B,IACCG,WAAW,IAAId,QAFlB,EAGE;AACAG,QAAAA,YAAY,GAAGU,aAAf;AACAZ,QAAAA,WAAW,GAAG,IAAd;AACD;AACF;AACF;;AACD,MAAIQ,YAAJ,EAAkB;AAChB,QAAMC,mBAAkB,GAAG,EAAEH,oBAAoB,IAAIX,YAA1B,CAA3B;;AACA,QAAI,CAACc,mBAAL,EAAyB;AACvBR,MAAAA,SAAS,GAAG,MAAZ;;AACA,UAAMW,cAAa,GAAGf,SAAS,IAAIJ,OAAO,GAAGD,KAAd,CAA/B;;AACA,UAAMsB,YAAY,GAAGhB,YAAY,KAAK,CAAtC;;AACA,UAAIc,cAAa,IAAI,CAAjB,IAAuBE,YAAY,IAAIf,QAA3C,EAAsD;AACpDC,QAAAA,WAAW,GAAG,IAAd;AACAE,QAAAA,YAAY,GAAGU,cAAf;AACD;AACF;AACF;;AACD,SAAO;AACLX,IAAAA,SAAS,EAATA,SADK;AAELC,IAAAA,YAAY,EAAZA,YAFK;AAGLF,IAAAA,WAAW,EAAXA;AAHK,GAAP;AAKD;;AAED,SAASZ,8BAAT","sourcesContent":["// this is to get the values for handling onTouchMove / onMouseMove;\nfunction populateSlidesOnMouseTouchMove(\n  state,\n  props,\n  initialX,\n  lastX,\n  clientX\n) {\n  const {\n    itemWidth,\n    slidesToShow,\n    totalItems,\n    transform,\n    currentSlide\n  } = state;\n  const { infinite } = props;\n  let canContinue = false; // it will be true if we have slides to slide to.\n  let direction; // either 'left' or 'right'\n  let nextPosition;\n  // making sure we have items to slide back to, prevent oversliding.\n  const slidesHavePassedRight = Math.round((initialX - lastX) / itemWidth);\n  const slidesHavePassedLeft = Math.round((lastX - initialX) / itemWidth);\n  const isMovingRight = initialX > clientX;\n  const isMovingLeft = clientX > initialX;\n  if (isMovingRight) {\n    const isAboutToOverSlide = !(slidesHavePassedRight <= slidesToShow);\n    if (!isAboutToOverSlide) {\n      direction = \"right\";\n      const translateXLimit = Math.abs(\n        -(itemWidth * (totalItems - slidesToShow))\n      );\n      const nextTranslate = transform - (lastX - clientX);\n      const isLastSlide = currentSlide === totalItems - slidesToShow;\n      if (\n        Math.abs(nextTranslate) <= translateXLimit ||\n        (isLastSlide && infinite)\n      ) {\n        nextPosition = nextTranslate;\n        canContinue = true;\n      }\n    }\n  }\n  if (isMovingLeft) {\n    const isAboutToOverSlide = !(slidesHavePassedLeft <= slidesToShow);\n    if (!isAboutToOverSlide) {\n      direction = \"left\";\n      const nextTranslate = transform + (clientX - lastX);\n      const isFirstSlide = currentSlide === 0;\n      if (nextTranslate <= 0 || (isFirstSlide && infinite)) {\n        canContinue = true;\n        nextPosition = nextTranslate;\n      }\n    }\n  }\n  return {\n    direction,\n    nextPosition,\n    canContinue\n  };\n}\n\nexport { populateSlidesOnMouseTouchMove };\n"]},"metadata":{},"sourceType":"module"}